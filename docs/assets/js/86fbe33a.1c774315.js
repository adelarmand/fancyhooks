"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[95],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return d}});var a=t(7294);function c(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){c(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,c=function(e,n){if(null==e)return{};var t,a,c={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(c[t]=e[t]);return c}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(c[t]=e[t])}return c}var o=a.createContext({}),p=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},s={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,c=e.mdxType,l=e.originalType,o=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),f=p(t),d=c,m=f["".concat(o,".").concat(d)]||f[d]||s[d]||l;return t?a.createElement(m,r(r({ref:n},u),{},{components:t})):a.createElement(m,r({ref:n},u))}));function d(e,n){var t=arguments,c=n&&n.mdxType;if("string"==typeof e||c){var l=t.length,r=new Array(l);r[0]=f;var i={};for(var o in n)hasOwnProperty.call(n,o)&&(i[o]=n[o]);i.originalType=e,i.mdxType="string"==typeof e?e:c,r[1]=i;for(var p=2;p<l;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},2674:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return o},default:function(){return d},frontMatter:function(){return i},metadata:function(){return p},toc:function(){return s}});var a=t(7462),c=t(3366),l=(t(7294),t(3905)),r=["components"],i={},o="useFancyEffect",p={unversionedId:"usefancyeffect",id:"usefancyeffect",title:"useFancyEffect",description:"It is like React.useEffect but has a helper which is fancy!",source:"@site/docs/usefancyeffect.md",sourceDirName:".",slug:"/usefancyeffect",permalink:"/fancyhooks/docs/usefancyeffect",editUrl:"https://github.com/fancyreact/fancyhooks/website/docs/usefancyeffect.md",tags:[],version:"current",frontMatter:{},sidebar:"main",previous:{title:"useFancyState",permalink:"/fancyhooks/docs/usefancystate"}},u={},s=[{value:"<code>fancyHelper</code> is Fancy!",id:"fancyhelper-is-fancy",level:2},{value:"Examples",id:"examples",level:2},{value:"newDeps",id:"newdeps",level:3},{value:"count",id:"count",level:3},{value:"prevDeps",id:"prevdeps",level:3},{value:"More",id:"more",level:2},{value:"How about <code>React.useEffect</code>",id:"how-about-reactuseeffect",level:3},{value:"On mount",id:"on-mount",level:3},{value:"Deal with cleanup",id:"deal-with-cleanup",level:3},{value:"What is <code>count</code>",id:"what-is-count",level:3}],f={toc:s};function d(e){var n=e.components,t=(0,c.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"usefancyeffect"},"useFancyEffect"),(0,l.kt)("p",null,"It is like ",(0,l.kt)("inlineCode",{parentName:"p"},"React.useEffect")," but has a helper which is ",(0,l.kt)("strong",{parentName:"p"},"fancy"),"!"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"useFancyEffect(callback, dependencyList, fancyHelper);\n")),(0,l.kt)("h2",{id:"fancyhelper-is-fancy"},(0,l.kt)("inlineCode",{parentName:"h2"},"fancyHelper")," is Fancy!"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"useFancyEffect")," passes an object with the following keys to ",(0,l.kt)("inlineCode",{parentName:"p"},"fancyHelper"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"newDeps")," Current dependency list. It passed to ",(0,l.kt)("inlineCode",{parentName:"li"},"useFancyEffect")," as first argument."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"prevDeps")," Previous dependency list."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"count")," Number of times",(0,l.kt)("inlineCode",{parentName:"li"},"dependencyList")," updated.")),(0,l.kt)("h2",{id:"examples"},"Examples"),(0,l.kt)("p",null,"Here are a few examples explaining usage of ",(0,l.kt)("inlineCode",{parentName:"p"},"useFancyEffect"),"."),(0,l.kt)("h3",{id:"newdeps"},"newDeps"),(0,l.kt)("p",null,"Executes ",(0,l.kt)("inlineCode",{parentName:"p"},"callback")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"input")," in dependency list is not empty."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"// App.jsx\n\nimport { useFancyEffect } from 'fancyhooks';\n\nexport function App() {\n  const [input, setInput] = React.useState('');\n\n  useFancyEffect(\n    // Callback,\n    // going to be executed\n    () => {\n      // API call...\n    },\n    // Dependency list\n    [input],\n    // Helper funcation,\n    // allows executing the `callback` if `input` is not empty\n    ({ newDeps }) => newDeps[0].length > 0,\n  );\n\n  const handleChagen = (evt) => {\n    setInput(evt.target.value);\n  };\n\n  return <input onChange={handleChange} value={input} />;\n}\n")),(0,l.kt)("h3",{id:"count"},"count"),(0,l.kt)("p",null,"Executes ",(0,l.kt)("inlineCode",{parentName:"p"},"callback")," if numer of dependency list updates are more than one."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"// App.jsx\n\nimport { useFancyEffect } from 'fancyhooks';\n\nexport function App() {\n  const [input, setInput] = React.useState('');\n\n  useFancyEffect(\n    // Callback,\n    // going to be executed\n    () => {\n      // API call...\n    },\n    // Dependency list\n    [input],\n    // Helper funcation,\n    // allows executing the `callback` if `input` changes more than on time,\n    // helps you ignore first rendering\n    ({ count }) => count > 1,\n  );\n\n  const handleChagen = (evt) => {\n    setInput(evt.target.value);\n  };\n\n  return <input onChange={handleChange} value={input} />;\n}\n")),(0,l.kt)("h3",{id:"prevdeps"},"prevDeps"),(0,l.kt)("p",null,"Executes ",(0,l.kt)("inlineCode",{parentName:"p"},"callback")," if values of state object changed.\nIt prevents calling API if you click on clicked button once again."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"// App.jsx\n\nimport { useFancyEffect } from 'fancyhooks';\n\nexport function App() {\n  const [filled, setFilled] = React.useState({ first: false, second: false });\n\n  const handleClick = (name) => {\n    setFilled({ ...filled, [name]: true });\n  };\n\n  useFancyEffect(\n    // Callback,\n    // going to be executed\n    () => {\n      // API call...\n    },\n    // Dependency list\n    [filled],\n    // Helper funcation,\n    // allows executing the `callback` if `filled` values changed\n    ({ newDeps, prevDeps }) => (\n      newDeps[0].first !== prevDeps[0].first || newDeps[0].second !== prevDeps[0].second\n    ),\n  );\n\n  return (\n    <>\n      <button onClick={() => handleClick('first')}>\n        first\n      </button>\n      <button onClick={() => handleClick('second')}>\n        second\n      </button>\n    </>\n  );\n}\n")),(0,l.kt)("h2",{id:"more"},"More"),(0,l.kt)("h3",{id:"how-about-reactuseeffect"},"How about ",(0,l.kt)("inlineCode",{parentName:"h3"},"React.useEffect")),(0,l.kt)("p",null,"If you ignore ",(0,l.kt)("inlineCode",{parentName:"p"},"helper")," function, the ",(0,l.kt)("inlineCode",{parentName:"p"},"useFancyEffect")," acts just like ",(0,l.kt)("inlineCode",{parentName:"p"},"React.useEffect"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"// App.jsx\n\nimport { useFancyEffect } from 'fancyhooks';\n\nexport function App() {\n  const [input, setInput] = React.useState('');\n\n  // Acts like `React.useEffect`\n  useFancyEffect(\n    () => {\n      // API call...\n    },\n    [input],\n  );\n\n  const handleChagen = (evt) => {\n    setInput(evt.target.value);\n  };\n\n  return <input onChange={handleChange} value={input} />;\n}\n")),(0,l.kt)("h3",{id:"on-mount"},"On mount"),(0,l.kt)("p",null,"If the dependency list is an empty arry the ",(0,l.kt)("inlineCode",{parentName:"p"},"fancyHelper")," will automatically be ignored by ",(0,l.kt)("inlineCode",{parentName:"p"},"useFancyEffect"),". So, on mount effects and their cleanups (unmount) always execute."),(0,l.kt)("h3",{id:"deal-with-cleanup"},"Deal with cleanup"),(0,l.kt)("p",null,"Logically ",(0,l.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup"},"cleanup function")," will be executed if ",(0,l.kt)("inlineCode",{parentName:"p"},"callback")," function executes. So, if ",(0,l.kt)("inlineCode",{parentName:"p"},"fancyHelper")," prevents executing ",(0,l.kt)("inlineCode",{parentName:"p"},"callback"),", no cleanup would be available."),(0,l.kt)("h3",{id:"what-is-count"},"What is ",(0,l.kt)("inlineCode",{parentName:"h3"},"count")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"count")," is number of times dependency list udpated. It does not matter if ",(0,l.kt)("inlineCode",{parentName:"p"},"fancyHelper")," executed or not, it is counting dependency list updates."))}d.isMDXComponent=!0}}]);